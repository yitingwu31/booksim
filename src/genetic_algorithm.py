# -*- coding: utf-8 -*-
"""genetic_algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kG6TNGIWxBbxiarmn9FWVrT_AU9EoI8L
"""

# genetic algorithm search for continuous function optimization
from numpy.random import randint
from numpy.random import rand

import numpy as np
import random

def score(candidate):
  # calculate its average latency of this path.  (based on latency == shorter latency means higher score)
  scorec = 88888  # run booksim on here:    # score == booksim avg. latency
  return scorec

def generate_gene(k, n, n_bits):    #generate DOR random paths (no deadlock)  list of (x,y) from start to end.
    # a gene is a column in the GA table
    # This gene has {2^(n_bits)-1} possible rows .
    sequence = []
    xi = randint(0, k-1)
    yi = randint(0, k-1)
    xf = xi
    yf = yi
    while (xi, yi) == (xf, yf):
      xf = np.random.choice(0, k-1)
      yf = np.random.choice(0, k-1)
    x = xi
    y = yi
    # Current pos:
    x, y = xi, yi
    sequence.append((x, y))
    # Move in +x direction
    while x < xf:
        x += 1
        sequence.append((x, y))
    # Move in +y direction
    while y < yf:
        y += 1
        sequence.append((x, y))
    while x > xf:
        x -= 1
        sequence.append((x, y))
    while y > yf:
        y -= 1
        sequence.append((x, y))
    return sequence


# tournament selection
def selection(pop, scores, k=3):
  # first random selection
  selection_ix = randint(len(pop))
  for ix in randint(0, len(pop), k-1):
    # check if better (e.g. perform a tournament)
    if scores[ix] < scores[selection_ix]:
      selection_ix = ix
  return pop[selection_ix]

# crossover two parents to create two children     here, crossover items in the table?
def crossover(p1, p2, r_cross):
  c1, c2 = p1.copy(), p2.copy()
  if rand() < r_cross:
    pt = randint(1, len(p1)-2)
    c1 = p1[:pt] + p2[pt:]
    c2 = p2[:pt] + p1[pt:]
  return [c1, c2]

def mutation(bitstring, r_mut):  #choose one random gene -> mutate a bit in its index
  for i in range(len(bitstring)):
    # check for a mutation
    if rand() < r_mut:
      # flip the bit
      bitstring[i] = 1 - bitstring[i]

def genetic_algorithm(k, n, bounds, n_genes, n_bits, n_chrom, n_iter, r_cross, r_mut):
  #init random population = (8 chroms):

  # generate a chroms from a fake GA table                in real C++ = (run GAinit.py )
  def generate_chrom(k, n, n_bits, n_genes): -> list(list)  #chrom is a list of random  "1011""0001""1110"

    # TODO: generate a bitstring index = "101..." n bits wide
    bistrings = []
    # TODO: fill up chrom as a random choice of index

    # generate n_genes random indices  0:n_bits
    chrom = [generate_gene(k,n, n_bits) for gene in range(n_genes)]
    return chrom

  population = [generate_chrom(k,n, n_genes) for chrom in range(n_chrom)]  #initialize the first population as a DOR routing

  # enumerate generations
  for gen in range(n_iter):

    scores = [score(candidate) for candidate in population]

    # select parents
    selected = [selection(population, scores) for _ in range(n_chrom)]

    pop = [randint(0, 2, n_genes*len(bounds)).tolist() for _ in range(n_chrom)]


    # keep track of best solution
    best, best_eval = 0, score()
    # enumerate generations
    for gen in range(n_iter):
      # evaluate all candidates in the population
      scores = [score(d) for d in decoded]
      # check for new best solution
      for i in range(n_chrom):
        if scores[i] < best_eval:
          best, best_eval = pop[i], scores[i]
          print(">%d, new best f(%s) = %f" % (gen,  decoded[i], scores[i]))

        # select parents
        selected = [selection(pop, scores) for _ in range(n_chrom)]
        # create the next generation
        children = list()
        for i in range(0, n_chrom, 2):
          # get selected parents in pairs
          p1, p2 = selected[i], selected[i+1]
          # crossover and mutation
          for c in crossover(p1, p2, r_cross):
            # mutation
            mutation(c, r_mut)
            # store for next generation
            children.append(c)
            # replace population
            pop = children
  return [best, best_eval]

# define range for input
k = 4
n = 2
n_iter = 100
n_chrom = 100  #pop size
n_genes = k ** m * (k ** n - 1)  #k^n * (k^n - 1)    =  S,D pairs
r_cross = 0.9 #crossover rate
r_mut = 1.0 / float(n_genes)  # mutate one out of every chrom

best, score = genetic_algorithm(k, n, bounds, n_genes, n_bits, n_chrom, n_iter, r_cross, r_mut)

print('Done!')
decoded = decode(bounds, n_genes, best)
print('f(%s) = %f' % (decoded, score))